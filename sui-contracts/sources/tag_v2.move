// <autogenerated>
//   This file was generated by dddappp code generator.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

module sui_blog_example::tag_v2 {
    use std::option;
    use std::string::String;
    use sui::event;
    use sui::object::{Self, UID};
    use sui::transfer;
    use sui::tx_context::TxContext;

    struct TAG_V2 has drop {}

    friend sui_blog_example::tag_v2_create_logic;
    friend sui_blog_example::tag_v2_aggregate;

    #[allow(unused_const)]
    const EDataTooLong: u64 = 102;
    const EInappropriateVersion: u64 = 103;
    const EEmptyObjectID: u64 = 107;

    fun init(otw: TAG_V2, ctx: &mut TxContext) {
        let keys = vector[
            std::string::utf8(b"image_url"),
        ];
        let values = vector[
            std::string::utf8(b"{https://arweave.net/{image_url}}"),
        ];
        let publisher = sui::package::claim(otw, ctx);
        let display = sui::display::new_with_fields<TagV2>(
            &publisher, keys, values, ctx
        );
        sui::display::update_version(&mut display);
        sui::transfer::public_transfer(publisher, sui::tx_context::sender(ctx));
        sui::transfer::public_transfer(display, sui::tx_context::sender(ctx));
    }

    struct TagV2 has key {
        id: UID,
        version: u64,
        name: String,
        image_url: String,
    }

    public fun id(tag_v2: &TagV2): object::ID {
        object::uid_to_inner(&tag_v2.id)
    }

    public fun version(tag_v2: &TagV2): u64 {
        tag_v2.version
    }

    public fun name(tag_v2: &TagV2): String {
        tag_v2.name
    }

    public(friend) fun set_name(tag_v2: &mut TagV2, name: String) {
        assert!(std::string::length(&name) <= 100, EDataTooLong);
        tag_v2.name = name;
    }

    public fun image_url(tag_v2: &TagV2): String {
        tag_v2.image_url
    }

    public(friend) fun set_image_url(tag_v2: &mut TagV2, image_url: String) {
        assert!(std::string::length(&image_url) <= 200, EDataTooLong);
        tag_v2.image_url = image_url;
    }

    public(friend) fun new_tag_v2(
        name: String,
        ctx: &mut TxContext,
    ): TagV2 {
        assert!(std::string::length(&name) <= 100, EDataTooLong);
        TagV2 {
            id: object::new(ctx),
            version: 0,
            name,
            image_url: std::string::utf8(b"6AXZZCbeJLoOiexVs4TbWYcBvAtHsP8j0b0TZCLovs0"),
        }
    }

    struct TagV2Created has copy, drop {
        id: option::Option<object::ID>,
        name: String,
    }

    public fun tag_v2_created_id(tag_v2_created: &TagV2Created): option::Option<object::ID> {
        tag_v2_created.id
    }

    public(friend) fun set_tag_v2_created_id(tag_v2_created: &mut TagV2Created, id: object::ID) {
        tag_v2_created.id = option::some(id);
    }

    public fun tag_v2_created_name(tag_v2_created: &TagV2Created): String {
        tag_v2_created.name
    }

    public(friend) fun new_tag_v2_created(
        name: String,
    ): TagV2Created {
        TagV2Created {
            id: option::none(),
            name,
        }
    }


    public(friend) fun freeze_object(tag_v2: TagV2) {
        assert!(tag_v2.version == 0, EInappropriateVersion);
        transfer::freeze_object(tag_v2);
    }

    fun update_object_version(tag_v2: &mut TagV2) {
        tag_v2.version = tag_v2.version + 1;
        //assert!(tag_v2.version != 0, EInappropriateVersion);
    }

    public(friend) fun drop_tag_v2(tag_v2: TagV2) {
        let TagV2 {
            id,
            version: _version,
            name: _name,
            image_url: _image_url,
        } = tag_v2;
        object::delete(id);
    }

    public(friend) fun emit_tag_v2_created(tag_v2_created: TagV2Created) {
        assert!(std::option::is_some(&tag_v2_created.id), EEmptyObjectID);
        event::emit(tag_v2_created);
    }

}
